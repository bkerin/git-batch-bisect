#!/usr/bin/perl -w

# See the associated README.md

# vim:foldmethod=marker

# Pragmas and Modules # {{{1

use strict;
use warnings FATAL => 'all';
use v5.20;
use feature qw(signatures);
no warnings qw(experimental::signatures);

use Carp qw( confess );
use Cwd qw( abs_path cwd );
use Data::Dumper;
use Fcntl;
use File::Path qw( make_path );
use File::Spec;
use File::Temp qw( tempfile );
use Getopt::Long qw( GetOptions );

# }}}1

# FIXXME: could do whatever the current magic is to discover our own name here
my $pn = 'batch-bisect';   # Program Name

sub system_bash ($cmd) { # {{{1 # Like system(), but use /bin/bash not /bin/sh
    my @args = ('/bin/bash', '-c', $cmd);
    return system(@args);
}
sub sysck ($cmd) { # {{{1 # Like system_bash() but error check is integrated
    not system_bash $cmd or confess "command '$cmd' returned non-zero";
} # }}}1
sub btck ($cmd) { # {{{1 # Like backticks but error check and chomp() are integrated
    my $result = `$cmd`;
    $? == 0 or confess "backtick command '$cmd' returned non-zero";
    chomp($result);
    return $result;
} # }}}1
sub btck_bash ($cmd) { # {{{1 Like backtick but use /bin/bash not /bin/sh

    # Temp File Handle.  Not requesting name means it will get auto-unlinked
    my $tfh = tempfile();

    # Keep temp file descriptor open across exec so we can use it from shell
    my $flags = fcntl $tfh, F_GETFD, 0 or die "fcntl F_GETFD: $!";
    fcntl $tfh, F_SETFD, $flags & ~FD_CLOEXEC or die "fcntl F_SETFD: $!";

    # Execute command using bash with stdout redirected to our temp file handle
    my @args = ('/bin/bash' , '-c', "($cmd)" ." >&".fileno($tfh));
    system(@args);

    # Seek back to start of temp file and read and return its contents
    seek $tfh, 0, 0 or die;
    my @lines = <$tfh>;
    return join("\n", @lines);

} # }}}1
sub mem_total () { # Total system memory accoding to /proc/meminfo, or -1 {{{1
    # Returns the MemTotal from /proc/meminfo, or -1 on failure
    my $regexp = '^MemTotal:\s+\K\d+(?=\s+kB)';
    my $result = `grep -oP '$regexp' /proc/meminfo`;
    $? == 0 or return -1;   # In case we're on BSD or something
    chomp($result);
    return $result;
} # }}}1
sub wtd () { # {{{1   # WorkTrees Dir

    # This sets the policy by which we decide where worktrees for the
    # individual commits should go

    my $cwd = cwd();
    my $cdn = [File::Spec->splitpath($cwd)]->[2];   # Current Dir Name
    my $result = "$cwd/../$cdn.$pn";   # Current Worktree Dir Path
    # Git's worktree namespace necessarily does this anyway: symlinking to
    # a repo and batch-bisect start ends up creating the same worktrees as
    # the non-symlinked repo would get.  So for (some) clarity we go ahead
    # and do it here.
    $result = abs_path($result);

    return $result;

} # }}}1
sub cwtp ($commit) { # {{{1   Commit WorkTree Path

    return wtd()."/$commit"

} # }}}1
sub trimmed_commit_list($lc, $fc, $fp, $paths) { # {{{1

  # Return list of commits between $fc and $lc subject to --first-parent

  my $pfpo = ($fp ? '--first-parent' : '');   # Possible --first-parent Option

  # Paths Part (as string of paths).  Note that when the [$paths] argument
  # passed to us was obtained by parsing git bisect log output these paths
  # may be quoted.  But that shouldn't matter.
  my $pp = join(' ', @$paths);

  # Commit List
  my @cl = split(/\n/, btck("git rev-list $pfpo $lc ^$fc -- $pp"));

  # At this point @cl will include $lc which we don't want, so make sure
  # we have it's SHA1 ($nbc might be a tag or something here) and remove it
  my $lc_sha1 = btck("git rev-parse --verify $lc^{commit}");
  @cl = map { $_ eq $lc_sha1 ? () : ($_) } @cl;   # Filter out $lc_sha1

  return @cl;

} # }}}1
sub commit_list() { # {{{1

  # Require that a bisection is in progress, and return list of commits in the
  # current bisection by parsing git bisect log output.

  my $blo = btck("git bisect log");   # Bisect Log Output

  # FIXXME: I'd rather use --term-old and --term-new here, and git bisect
  # terms supports them but doesn't document that support at the moment so
  # I'm staying iwth good/bad for now
  my $old_term = btck("git bisect terms --term-good");
  my $new_term = btck("git bisect terms --term-bad");

  # FIXXME: this is probably fragile and it might be better to look in
  # ./.git/refs/bisect or something
  #
  # First and second lines are the initial old/new commits
  my ($bl1, $bl2) = (split(/\n/, $blo))[0,1];   # $blo line 1/2
  my $mcc = 27;   # I think commits as showin in log are always >this long
  $bl1 =~ m/^# \Q$new_term\E: \[([a-f0-9]{$mcc,})\]\s+.*$/m
      or confess "unexpected match failure";
  my $lc = $1;   # Last Commit
  $bl2 =~ m/^# \Q$old_term\E: \[([a-f0-9]{$mcc,})\]\s+.*$/m
      or confess "unexpected match failure";
  my $fc = $1;   # First Commit

  $blo =~ m/^git bisect start (.*)$/m or confess "unexpected match failure";
  my $bsoaa = $1;   # Bisect Start Opts And Args

  my $fp = ($bsoaa =~ m/'(--first-parent)'/);   # --first-parent?

  # Paths arguments (if any) as an array
  my @paths = split(' ', ($bsoaa =~ m/'--'\s+([^\s].*)$/ ? $1 : ''));

  my @cl = trimmed_commit_list($lc, $fc, $fp, \@paths);

  return @cl;

} # }}}1
sub opt_descriptions ($opts) { # {{{1

    # Return a more man-esque array of option descrtiptions from the kind
    # normally given to GetOptions

    return [ sort map {  m/^([-\w|?]+)$/ ?
                         "--$1" :
                         ( m/^([-\w|]+)=i/ ?
                           "--$1=INT" :
                           ( m/^([-\w|]+)=f/ ?
                             "--$1=FLOAT" :
                             ( m/^([-\w|]+)=s/ ?
                               "--$1=STRING" :
                               () ) ) ) }
                      %$opts ];
} # }}}1
sub usage ($action, $opts, $args) # {{{1
{
    return(
        "\n  $pn $action usage:\n\n  $0\n    ".
        join("\n    ", @{opt_descriptions($opts)})."\n    $args\n\n" );
} # }}}1
sub cnoa ($avr, $relation, $count, $action) { # Check Number Of Arguments {{{1

    my $ac = scalar(@$avr);   # Arg Count (from @ARGV ref)

    my $is_correct = 1;
    if    ( $relation eq '==' ) {
        ($ac == $count) or ($is_correct = 0);
    }
    elsif ( $relation eq '>=' ) {
        ($ac >= $count) or ($is_correct = 0);
    }
    else {
        confess "shouldn't be here";
    }

    my $staon = ($action ? " $action" : '');   # Space Then Action Or Nothing

    $is_correct
        or die "wrong number of arguments for $pn$staon, try `$pn$staon ".
               "--help'\n";

} # }}}1
sub is_valid_term_action ($action) { # {{{1

    # Return true iff $action is one of the normal term actions
    # (new|bad|old|good) or a bisection is in progress and $action is a
    # custom term action previously specified with --term-(new|bad|old|good).
    # Note that true is always returned for literal (new|bad|old|good)
    # even if the other pair of terms or a custom term action is in use
    # (git bisect always recognizes these words even if they're wrong for
    # the current case, so we end up wanting to let them through at this
    # point and let git bisect show the error later).

    if ( $action =~ m/^(?:new|bad|old|good)$/ ) {
        return 1;
    }
    elsif ( not system("git bisect log 1>/dev/null 2>/dev/null") ) {
        return (
            $action eq btck("git bisect terms --term-bad")
                or
            $action eq btck("git bisect terms --term-good") );
    }
    else {
        return 0;
    }

} # }}}1
sub is_ancestor ($ra, $rb) { # {{{1

    # Return true iff $ra is an ancestor of $rb, or false iff it isn't,
    # or confess on other error.


    my $cmd = "git merge-base --is-ancestor $ra $rb";
    my $es = system($cmd);

    system($cmd);
    if ( $? != 0 ) {
        # Voodoo to get actual Exit Status, see perl -f system
        my $es = ($? >> 8);
        # git merge-base returns > 1 on error (and 1 on "not ancestor")
        $es == 1 or confess "exit status of `$cmd' was > 1";
    }

    return not $?;

} # }}}1

# Per-repository lock {{{1

my $ld = "/tmp/$pn-locks".cwd();   # Lock Dir
make_path($ld);
my $lf = "$ld/lock";   # Lock File

(not -e $lf and sysck("touch $lf"))
    or die "lock file $lf already exists, and only one copy of $pn per ".
           "repository can run at a time.  If you know the lock is stale ".
           "simply remove it";

# This will clean up the lock unless user kills us with an unhandleable signal
END {
    unlink($lf) or die "failed to unlink $lf: $!";
}

# }}}1

cnoa(\@ARGV, ">=", 1, "");

my $action = shift @ARGV;

if    ( $action eq 'start' ) { # {{{1

    # Option and argument parsing {{{2

    my $fp = 0;   # --first-parent (flag)
    my $hf = 0;   # Help Flag
    my $nc = 0;   # --no-checkout (flag)
    my ($tn, $tb, $to, $tg) = (0, 0, 0, 0);   # --term-{new,bad,old,good}
    my %opts = (
        "first-parent"       => \$fp,
        "help|?"             => \$hf,
        "no-checkout"        => \$nc,
        "term-new=s"         => \$tn,
        "term-bad=s"         => \$tb,
        "term-old=s"         => \$to,
        "term-good=s"        => \$tg );

    # git bisect interprets '--' differently than GetOptions() of
    # Getopt::Long: the former requires it to seperate [<bad> [<good>]]
    # rev arguments from <path> arguments, while GetOptions() considers it
    # to indicate that all the following arguments are not to be considered
    # options (regardless of any leading '-' or '--') and filters it out
    # when it runs.  So we have to check for it here and pop off any <path>
    # arguments before calling GetOptions().
    my @paths = ();
    for ( my $ii = 0 ; $ii < @ARGV ; $ii++ ) {
        if ( $ARGV[$ii] eq '--' ) {
            if ( @ARGV > $ii + 1 ) {
                push(@paths, splice(@ARGV, $ii + 1));
            }
        }
    }

    GetOptions(%opts)
        or die "\nError parsing options.  Try `$pn $action --help'.\n";

    if ( $hf ) {
        print usage($action, \%opts, '<bad> <good>... [--] [<path>...]');
        exit(0)
    }

    # Re-expanding these like this so we can pass them to the git commands is
    # sort of dumb but keeps argument counting simple.  Users who are using
    # quotes in their terms are boned though :)
    my $pfpo = $fp ? '--first-parent' : '';   # Possible --first-parent Option
    my $pnco = $nc ? '--no-checkout' : '';    # Possible --no-checkout Option
    my $pto = (                               # Possible --term-* Options
        ($tn ? "--term-new='$tn' "  : '') .
        ($tb ? "--term-bad='$tb' "  : '') .
        ($to ? "--term-old='$to' "  : '') .
        ($tg ? "--term-good='$tg' " : '') );

    if ( @ARGV < 2 ) {
        # We require this because it avoids the wierd state of
        # "started-but-not-bounded-yet and lets us set up the commit worktrees
        # up front.
        die "\n".
            "too few non-<path> arguments to $pn start subcommand.  Unlike ".
            "git bisect start, batch-bisect start requires that a bad commit ".
            "and at least one good commit be provided to the start command.\n".
            usage($action,\%opts, '<bad> <good>... [--] [<path>...]');
    }

    # Note that we already remove any <path>s arguments above (and GetOptions()
    # remove any '--' arguments)
    my ($nbc, $obc) = @ARGV;   # New/Old Behavior Commit

    not system("git rev-parse --quiet --verify $nbc^{commit} >/dev/null")
        or die "`$nbc' doesn't look like a commit";
    not system("git rev-parse --quiet --verify $obc^{commit} >/dev/null")
        or die "`$obc' doesn't look like a commit";

    # }}}2

    # Check that $obc-$nbc relationship is sane {{{2

    # As of this writing (2023-12-17) git gives this crap message when $nbc is
    # an ancestor of $obc:
    #
    #    $ git bisect start oldest_commit newest_commit
    #    Some good revs are not ancestors of the bad rev.
    #    git bisect cannot work properly in this case.
    #    Maybe you mistook good and bad revs?
    #
    # This is bad because it's wrong in general: if <good> is not an ancestor
    # of <bad> because <good> is on an unmerged branch git will automatically
    # find the common ancestor and use that as the starting <good> point for
    # the bisection (and it then correctly notices if the <good> behavior is
    # in fact introduced on the branch with it's subsequent messaging).  So
    # here we give a message describing the actual problem.
    #
    not is_ancestor($nbc, $obc)
        or die "bad (new behavior) commit `$nbc' is an ancestor of good (old ".
               "behavior) commit `$obc'.  Maybe you got the good/bad ".
               "(old/new) commits swapped?";

    if ( not is_ancestor($obc, $nbc) ) {

        # Common Ancestor-Finding Command
        my $cafc = "git merge-base $obc $nbc";

        # I'm not sure when this would happen but for caution let's trap it
        not system("$cafc 1>/dev/null 2>/dev/null")
            or confess "commit `$obc' is not an ancestor of `$nbc' or vice ".
                       "versa and `git merge-base $obc $nbc' failed to find ".
                       "common ancestor";

        # FIXME: WORK POINT: ok in our with_unmerged_branch I currently see
        # this behavior:
        #
        #     $ git bisect start master unmerged_test_branch 32d0cd24973d35ad97bdc747ac29f21b06f18bce
        #     Bisecting: a merge base must be tested
        #     [b93212577c2e8603ed7285b55a0931dcf552c628] I'm yet another test commit
        #     $ git bisect bad
        #     The merge base b93212577c2e8603ed7285b55a0931dcf552c628 is bad.
        #     This means the bug has been fixed between b93212577c2e8603ed7285b55a0931dcf552c628 and [1b4470e66cb26244be9aa5f68cca042a0ef4270e 32d0cd24973d35ad97bdc747ac29f21b06f18bce].
        #
        # See the gitk also, that report seems to be saying the bug is fixed by going back in time from the merge point, or forward in time on the branch.
        # Yikes.  Multiple <good> marks with merge base testing is implemented
        # so I guess probably somebody is using it in some non-redundant way
        # but I think I'm not interested and will just keep on having
        # batch-bisect advise the user to use merge-base manually when it runs
        # into this stuff.
        #
        # But this behavior in with_merged_branch looks more useful:
        #
        #     $ git bisect start master fc7a1fe274a3cd0111ccd882da8043ac39bfeeb0 18071e1457c87879f6493af39bcff46cdf5bc6fc
        #     Bisecting: 4 revisions left to test after this (roughly 2 steps)
        #     [443d45cca04ae3ab9af44985dab476e3a145db77] Yet another test commit on a test branch
        #     ---------------------------------------------------------------------------
        #     $ git bisect good
        #     Bisecting: 2 revisions left to test after this (roughly 1 step)
        #     [fd6cee3792048661c126af58f228b4abaabd6b1b] Yet another commit on master after test branch
        #     ---------------------------------------------------------------------------
        #     $ git bisect bad
        #     Bisecting: 0 revisions left to test after this (roughly 0 steps)
        #     [65a03b0db813b6a6164f3ddc97d5a12590273e71] Another commit on master after test branch
        #     ---------------------------------------------------------------------------
        #     $ git bisect bad
        #     65a03b0db813b6a6164f3ddc97d5a12590273e71 is the first bad commit
        #     commit 65a03b0db813b6a6164f3ddc97d5a12590273e71
        #     Author: Britton Leo Kerin <britton.kerin@gmail.com>
        #     Date:   Sun Dec 3 09:33:31 2023 -0900
        #
        #         Another commit on master after test branch
        #
        #      file_a | 1 +
        #      1 file changed, 1 insertion(+)
        #     ---------------------------------------------------------------------------
        #
        # Here the multiple <good> markes on the different merges brances have
        # saved us some testing.  I guess to implement this <good> essentially
        # has to turn into an array.  git bisect log records all the goods,
        # so things that look at that might need to change.  I'm not sure how
        # much more hassle getting the full set of revs would be but I think
        # rev-list can do it pretty easily.

        die "$obc isn't an ancestor of $nbc.  In this situation git ".
           "bisect normally automagically selects a common ancestor for ".
           "the starting point.  Partly for implementation reasons and ".
           "partly because it's potentially confuing to do that (the \"old\" ".
           "behavior might after all have been introduced in one of the ".
           "non-common commits as discussed here: ".
           "https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-bisect-lk2009.html".
           ") $pn doesn't do it, but you can use `$cafc' to find a common ".
           "ancestor to use instead of $obc (i.e. manually do what regular ".
           "`git bisect start' does in this situation)";

    }

    # }}}2

    # Ensure dir where we will keep worktrees exists # {{{2

    my $wtd = wtd();

    if ( -e $wtd ) {
        -d $wtd or confess "'$wtd' exists but is not a directory";
    }
    else {
        -e $wtd or mkdir $wtd
            or confess "failed to create directory '$wtd': $!";
    } # }}}2

    # The underlying git bisect start command tolerates invocation when
    # bisection is already in progress but FIXXME: I don't know why and
    # don't feel like figuring it out and decided what batch-bisect should do
    system_bash("git bisect log &>/dev/null")
        or die "bisection (possibly batch-bisection) already in progress\n";

    # FIXXME: currently we make no attempt to unwind this on err creating
    # working trees below.  But I think all those fails are pretty much bugs
    # (or maybe out of disk space :)
    sysck("git bisect start $pto $pnco $pfpo $nbc $obc -- ".join(' ', @paths));

    my @cl = trimmed_commit_list($nbc, $obc, $fp, \@paths);

    # Ensure worktrees exist # {{{2
    my $use_worktrees = 1;
    foreach ( @cl ) {
        my $cp = cwtp($_);   # Commit Path
        unless ( $use_worktrees ) {
            die "this code path worked to create the dir at least but hasn't ".
                "been used for other actions (e.g. cleanupall)";
            # FIXXME: well pcb doesn't ./autogen.sh correctly from a dir
            # created this way (though the source reads like it intends to),
            # and I bet this is pretty common these days, so probably the
            # worktree way should be the default, and idk if we even want
            # to suppport this
            (-d $cp and next)
                or mkdir $cp or confess "failed to create directory '$cp': $!";
            # Well this is stupid but I didn't find a better and easy way
            # to do it.  We could probably safely parallel this but I'm sure
            # that's not in spec.
            sysck("(git archive $_ -o $cp/tmp.tar && cd $cp && tar xf tmp.tar)");
        }
        else {
            (-d $cp and next) or sysck("git worktree add --detach $cp $_");
        }
    } # }}}2

} # }}}1
elsif ( $action eq 'runinall' ) { # {{{1

    # Run an instance of a command in each of the commit trees.  The stdout
    # and stderr of the commands is redirected to log files (unless the user
    # redirects it somewhere else in their provided command).

    my $cmd = join(' ', @ARGV);

    # Require an ongoing bisection (which we assume is a $pn :)
    not system("git bisect log >/dev/null") or exit 1;

    my $wtd = wtd();   # WorkTree Dir

    my @cl = commit_list();   # Commit List

    my @cdp = map { cwtp($_) } @cl;   # Commit Dir Paths

    print 'About to run command `'.$cmd."' in all ".scalar(@cdp)." commit ".
          "tree dirs\n";

    # FIXME: rather than just doc, should the output say where stuff is
    # being logged?

    my $qec = ($cmd =~ s/'/'"'"'/gr);   # Quote-escaped Command

    # Wrapped Quote-Escaped Command (to be invoked by GNU Parallel).
    # This puts us in the right dir and does logging
    my $wqec = "(cd {} && (((($qec) 1>{}.stdout_log 2>{}.stderr_log) && echo command succeeded in {}) || ((echo command failed in {} 1>&2) && false)))";

    # Cobble together a decent --memsuspend option to try, iff /proc/meminfo is
    # available
    my $mt_kb = mem_total();   # Mem Total in kB
    my $mvpt = 0.10;   # --memsuspend value percent total
    my $mv_kb = sprintf "%.0f", $mt_kb * $mvpt;   # --memsuspend value in kB
    my $mso = ( $mt_kb != -1 ? "--memsuspend=${mv_kb}k": '');

    # Use a temp file and :::: rather than ::: to avoid too long command line:
    my ($tfh, $tfn) = tempfile();   # Temp File Handle/Name
    print $tfh join("\n", @cdp) or confess;
    close $tfh or confess;
    # Parallel Command
    my $pc = "parallel --plain --nice=17 --load=80% $mso '$wqec' :::: $tfn";
    not system_bash $pc or die "command failed in at least one commit tree";
    unlink $tfn or confess;

} # }}}1
elsif ( $action eq 'runinrange' ) { # {{{1

    die "FIXXME: could implement this to run build commands for just a range ".
        "of commits (so we could bisect across a change in build procedure)";

} # }}}1
elsif ( $action eq 'runincurrent' ) { # {{{1

    # Run a command in the worktree associated with the commit currently
    # being tested.  This is presumably a test command of some sort, so
    # stdout and stderr are not redirected anywhere (and no logging is done).

    # Require an ongoing bisection (which we assume is a $pn :)
    not system("git bisect log >/dev/null") or die "no bisection in progress";

    my $cmd = join(' ', @ARGV);

    my $od = cwd();   # Old Dir

    # Current Commit SHA1.  First look for BISECT_HEAD which will be present
    # if we're in a --no-checkout bisection, and if that isn't there assume
    # we're not in a --no-checkout bisection and look for HEAD.
    my $ccs = `git rev-parse --verify BISECT_HEAD^{commit} 2>/dev/null`;
    if ( $? != 0 ) {
        $ccs = btck('git rev-parse --verify HEAD^{commit}');
    }
    else {
        chomp($ccs);
    }

    my $wtp = cwtp($ccs);
    chdir($wtp) or confess("chdir(\"$wtp\") failed: $!");

    not system_bash $cmd or die "command failed in current commit tree";

    chdir($od) or confess("chdir(\"$od\") failed: $!");

} # }}}1
elsif ( is_valid_term_action($action) ) { # {{{1

    sysck("git bisect $action ".join(' ', @ARGV));

} # }}}1
elsif ( $action eq 'terms' ) { # {{{1

    sysck("git bisect terms ".join(' ', @ARGV));

} # }}}
elsif ( $action eq 'skip' ) { # {{{1

    sysck("git bisect skip ".join(' ', @ARGV));

} # }}}1
elsif ( $action eq 'reset' ) { # {{{1

    sysck("git bisect reset ".join(' ', @ARGV));

} # }}}1
elsif ( $action eq 'visualize' or $action eq 'view' ) { # {{{1

    sysck("git bisect visualize ".join(' ', @ARGV));

} # }}}1
elsif ( $action eq 'replay' ) { # {{{1

    @ARGV == 1 or die "wrong number of arguments for $action";

    my $logfile = $ARGV[0];

    sysck("git bisect replay $logfile");

} # }}}1
elsif ( $action eq 'log' ) { # {{{1

    @ARGV == 0 or die "wrong number of arguments for $action";

    sysck("git bisect log");

} # }}}1
elsif ( $action eq 'run' ) { # {{{1

    sysck("git bisect run ".join(' ', @ARGV));

} # }}}1
elsif ( $action eq 'help' or $action eq '--help' or $action eq '-?' ) { # {{{1

    # FIXXME: add runinrange in here if it gets implemented:
    print <<"END_TOP_LEVEL_HELP";

    $pn COMMAND [OPTION]...

    COMMAND is one of:

      start
      runinall
      runincurrent
      new
      old
      terms
      skip
      reset
      visualize
      replay
      log
      run
      cleanupall
      help

    Please see also the markdown for $pn-specific help.  For help with git
    bisect try `git bisect help' or `man git-bisect'.

END_TOP_LEVEL_HELP

} # }}}1
elsif ( $action eq 'cleanupall' ) { # {{{1

    # Remove *all* batch-bisect-related worktrees and the worktree directory
    # and end any current bisection (with git bisect reset).  This should
    # remove everything even if some other operation failed in the middle.
    #
    # FIXXME: There is currently no automatic way to do partial cleanup: either
    # all the commits and worktrees stay around, or they are nuked en masse
    # with this action.  Middle policies would of course be possible but are
    # painful to specify and implement for a since wtd() (probably the most
    # useful fix would be to implement a -d option to specify worktree to use
    # other than the default).

    @ARGV == 0 or die "wrong number of arguments for $action";

    my $wtd = wtd();

    # git worklist records the names as absolute paths so get those
    my $abs_wtd = abs_path($wtd);

    # Worktree List (only our worktrees filtered in)
    my @wl
        = map
            { m/\Q$abs_wtd\E/ ? ($_) : () }
            split(/\n/, btck("git worktree list | cut -d ' ' -f 1"));

    foreach ( @wl ) { sysck("git worktree remove --force $_"); }

    sysck("rm -rf $wtd");

    sysck("git bisect reset");

} # }}}1
else { # {{{1

        die "invalid action '$action'";

} # }}}1
